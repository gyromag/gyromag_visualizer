<!doctype html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>Gyromag Visualizer</title>

    <!-- Babylon.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
    <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
    <script src="https://cdn.babylonjs.com/recast.js"></script>
    <script src="https://cdn.babylonjs.com/ammo.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script>
    <script src="https://cdn.babylonjs.com/Oimo.js"></script>
    <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/addons/babylonjs.addons.min.js"></script>
    <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #canvasZone {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

</script>

<body>
    <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
    <script>

        // Parse initial values from URL query string
        function parseInitialValues() {
            const URLparams = new URLSearchParams(window.location.search);
            const initialValues = {};
            for (const [key, value] of URLparams.entries()) {
                // Try to parse as float, fallback to string
                const num = parseFloat(value);
                initialValues[key] = isNaN(num) ? value : num;
            }
            return initialValues;
        }

        window.initialValues = parseInitialValues();

        console.log("Initial values:", window.initialValues);

        var canvas = document.getElementById("renderCanvas");

        var startRenderLoop = function (engine, canvas) {
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    sceneToRender.render();
                }
            });
        }

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function () { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true, disableWebGL2Support: false }); };
        var createScene = function () {
            var scene = new BABYLON.Scene(engine);

            var camera = new BABYLON.ArcRotateCamera("Camera", -0.4 * Math.PI, 0.4 * Math.PI, 5, BABYLON.Vector3.Zero(), scene);
            //var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
            camera.panningSensibility = 0;

            var light = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0.5, 3, 0), scene);
            //    new BABYLON.AxesViewer(scene, 1  );


            var atom = BABYLON.MeshBuilder.CreateSphere("Atom", { diameter: 0.12 }, scene);

            const ArrowCurve = (ep) => {
                const path = [];
                const len = ep.length();
                var head;
                if (len >= 0.08) {
                    head = ep.scale((len - 0.08) / len);
                } else {
                    head = new BABYLON.Vector3(0, 0, 0);
                }

                path.push(new BABYLON.Vector3(0, 0, 0))
                path.push(head),
                    path.push(head),
                    path.push(head),
                    path.push(head),
                    path.push(ep)
                return path;
            };

            const LaserArrowCurve = (dir) => {
                const dirrad = dir * Math.PI / 180;

                ep = new BABYLON.Vector3(
                    -1. * Math.sin(dirrad),
                    -1. * Math.cos(dirrad),
                    0
                );

                head = new BABYLON.Vector3(
                    -0.3 * Math.sin(dirrad),
                    -0.3 * Math.cos(dirrad),
                    0
                );
                tip = new BABYLON.Vector3(
                    -0.22 * Math.sin(dirrad),
                    -0.22 * Math.cos(dirrad),
                    0
                );

                const path = [];

                path.push(ep)
                path.push(head),
                    path.push(head),
                    path.push(head),
                    path.push(head),
                    path.push(tip)
                return path;
            };


            const AxisCurve = (ep) => {
                const path = [];
                const len = ep.length();
                const head = ep.scale((len - 0.1) / len);
                path.push(new BABYLON.Vector3(-ep.x, -ep.y, -ep.z))
                path.push(head),
                    path.push(head),
                    path.push(head),
                    path.push(head),
                    path.push(ep)
                return path;
            };

            const BradiusChange = (index, distance) => {
                var radius;
                if (index < 3) {
                    radius = 0.02;
                } else if (index < 5) {
                    radius = 0.04;
                } else {
                    radius = 0;
                }
                return radius;
            };

            const MagradiusChange = (index, distance) => {
                var radius;
                if (index < 3) {
                    radius = 0.025;
                } else if (index < 5) {
                    radius = 0.05;
                } else {
                    radius = 0;
                }
                return radius;
            };

            const MagPradiusChange = (index, distance) => {
                var radius;
                if (index < 3) {
                    radius = 0.023;
                } else if (index < 5) {
                    radius = 0.046;
                } else {
                    radius = 0;
                }
                return radius;
            };


            const smallradiusChange = (index, distance) => {
                var radius;
                if (index < 3) {
                    radius = 0.010;
                } else if (index < 5) {
                    radius = 0.030;
                } else {
                    radius = 0;
                }
                return radius;
            };


            /*
                        var skybox = BABYLON.MeshBuilder.CreateBox("skyBox", { size: 1000.0 }, scene);
            
                        var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
            
                        skyboxMaterial.backFaceCulling = false;
                        skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("textures/skybox", scene);
                        skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
                        skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
                        skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0); skybox.material = skyboxMaterial;
            */

            // This targets the camera to scene origin
            camera.setTarget(BABYLON.Vector3.Zero());


            // This attaches the camera to the canvas
            camera.attachControl(canvas, true);

            camera.lowerRadiusLimit = 2;// (debugNode as BABYLON.ArcRotateCamera)
            camera.upperRadiusLimit = 100;// (debugNode as BABYLON.ArcRotateCamera)
            camera.panningSensibility = 1000;// (debugNode as BABYLON.ArcRotateCamera)
            camera.speed = 1;// (debugNode as BABYLON.ArcRotateCamera)
            camera.inertia = 0.3;// (debugNode as BABYLON.ArcRotateCamera)
            camera.angularSensibilityX = 100;// (debugNode as BABYLON.ArcRotateCamera)
            camera.angularSensibilityY = 100;// (debugNode as BABYLON.ArcRotateCamera)

            // Parse initial values from URL or use defaults
            let B0s = typeof window.initialValues.B0m === "number" ? window.initialValues.B0m : 0;
            let B0act = typeof window.initialValues.B0m === "number" ? true : false;

            let B1s = typeof window.initialValues.B1f === "number" ? window.initialValues.B1f : 0;
            
            let B1act = B1s==0 ? false : true ;

            let B1a = typeof window.initialValues.B1a === "number" ? window.initialValues.B1a : 5;

            let relax = typeof window.initialValues.relax === "number" ? window.initialValues.relax : 0;
            let pump = typeof window.initialValues.pump === "number" ? window.initialValues.pump : 0;
            let pumpdir = typeof window.initialValues.pumpdir === "number" ? window.initialValues.pumpdir : 0;
            let B0d = typeof window.initialValues.B0d === "number" ? window.initialValues.B0d : 0; // direction in degrees
            let Fs = typeof window.initialValues.Fs === "number" ? window.initialValues.Fs : 0;
            let showaxis = typeof window.initialValues.showaxis === "number" ? window.initialValues.showaxis : true;
            let larmorth = typeof window.initialValues.larmorth === "number" ? window.initialValues.larmorth : false;
            
            let mag = new BABYLON.Vector3(1.,1., 1.);

            if(pump>0)
            {            
                mag = new BABYLON.Vector3(0.,0., 0);
            } else if (B1s !=0)
            {
                mag = new BABYLON.Vector3(0.,1., 0);
            }
            

            let rfvec = new BABYLON.Vector3(0.3, 0, 0); // Radiofrequency vector
            
            // GUI
            var gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

            let pulse = 0;

            let histPoints = [];
            let histcolors = [];
            for (let i = 0; i < 1000; i++) {
                histPoints.push(mag.clone());
                histcolors.push(new BABYLON.Color4(1, 1, 0, i / 1000.)); // yellow
            }
            console.log("histPoints: " + histPoints.length);

            // Define the resethist function
            function resethist() {
                for (let i = 0; i < 1000; i++) {
                    histPoints[i] = mag.clone();
                }
            }

            var Masaerpanel = new BABYLON.GUI.StackPanel();
            Masaerpanel.isVertical = true;

            Masaerpanel.width = "100%";
            Masaerpanel.paddingBottom = "20px";
            Masaerpanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
            Masaerpanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            gui.addControl(Masaerpanel);



            var LabelPanel = new BABYLON.GUI.StackPanel();
            LabelPanel.isVertical = true;
            LabelPanel.width = "100%";
            LabelPanel.paddingTop = "20px";
            LabelPanel.paddingLeft = "20px";
            LabelPanel.paddingRight = "20px";
            LabelPanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            LabelPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;

            const LabelTitle = new BABYLON.GUI.TextBlock();            
            LabelTitle.text = `GYROMAG Viaulizer`;            
            LabelTitle.color = "white";
            LabelTitle.fontSize = 38;
            LabelTitle.height = "40px";
            LabelTitle.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            LabelPanel.addControl(LabelTitle);

            const LabelAuthor = new BABYLON.GUI.TextBlock();            
            LabelAuthor.text = `georg.bison@psi.ch`;            
            LabelAuthor.color = "white";
            LabelAuthor.fontSize = 18;
            LabelAuthor.height = "35px";
            LabelAuthor.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            LabelPanel.addControl(LabelAuthor);

            
            const LabelMag = new BABYLON.GUI.TextBlock();            
            LabelMag.text = `Magnetization (ensemble avg. spin)`;            
            LabelMag.color = "yellow";
            LabelMag.fontSize = 24;
            LabelMag.height = "50px";
            LabelMag.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            LabelMag.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
            LabelPanel.addControl(LabelMag);


            const LabelB = new BABYLON.GUI.TextBlock();            
            LabelB.text = `Magnetic fields`;            
            LabelB.color = "green";
            LabelB.fontSize = 24;
            LabelB.height = "40px";
            LabelB.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            LabelB.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
            LabelPanel.addControl(LabelB);

            const LabelLaser = new BABYLON.GUI.TextBlock();            
            LabelLaser.text = `Pump laser`;            
            LabelLaser.color = "red";
            LabelLaser.fontSize = 24;
            LabelLaser.height = "40px";
            LabelLaser.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            LabelLaser.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
            LabelPanel.addControl(LabelLaser);


            gui.addControl(LabelPanel);



            const grid = new BABYLON.GUI.Grid();
            grid.addColumnDefinition(2);  // Column 1: fixed width
            grid.addColumnDefinition(1);  // Column 3: fixed width            
            grid.addRowDefinition(105, true);

            grid.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            grid.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            grid.width = "100%";
            grid.height = "115px";
            //            grid.paddingLeft = "20px";
            //          grid.paddingRight = "20px";
            //grid.paddingTop = "10px";
            grid.paddingBottom = "10px";
            Masaerpanel.addControl(grid);

            const grid2 = new BABYLON.GUI.Grid();
            grid2.addColumnDefinition(55, true);  // Column 1: fixed width
            grid2.addColumnDefinition(30, true);        // Column 2: relative width
            grid2.addColumnDefinition(2);  // Column 3: fixed width                 
            grid2.addColumnDefinition(80, true);        // Column 2: relative width       
            grid2.addColumnDefinition(1);  // Column 3: fixed width                        
            grid2.addColumnDefinition(100, true);        // Column 2: relative width
            grid2.addRowDefinition(35, true);
            grid2.addRowDefinition(35, true);
            grid2.addRowDefinition(35, true);
            grid2.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
            grid2.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            grid2.width = "100%";
            grid2.paddingLeft = "20px";
            grid2.paddingRight = "20px";

            const grid3 = new BABYLON.GUI.Grid();
            grid3.addColumnDefinition(60, true);  // Column 1: fixed width
            grid3.addColumnDefinition(2);  // Column 3: fixed width                 
            grid3.addColumnDefinition(80, true);        // Column 2: relative width       
            grid3.addRowDefinition(35, true);
            grid3.addRowDefinition(35, true);
            grid3.addRowDefinition(35, true);
            grid3.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
            grid3.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            grid3.width = "100%";
            grid3.paddingLeft = "20px";
            grid3.paddingRight = "20px";

            //            grid2.height = "75px";

            grid.addControl(grid2, 0, 0);
            grid.addControl(grid3, 0, 1);

            // B0 controls ************************************************************

            const labelB0 = new BABYLON.GUI.TextBlock();

            const valueB0 = new BABYLON.GUI.TextBlock();
            const valueB0d = new BABYLON.GUI.TextBlock();
            const checkbox1 = new BABYLON.GUI.Checkbox();
            const sliderB0 = new BABYLON.GUI.Slider();
            const sliderB0d = new BABYLON.GUI.Slider();

            labelB0.text = `B0`;
            labelB0.color = "white";
            labelB0.fontSize = 18;
            labelB0.height = "25px";
            labelB0.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;

            valueB0.text = `B0 R = 0`;
            valueB0.color = "white";
            valueB0.fontSize = 18;
            valueB0.height = "25px";
            valueB0.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;

            const B0_active = (value) => {
                B0act = value;
                sliderB0.alpha = value ? 1 : 0.4;
                sliderB0.value = B0s;
                valueB0.text = "R = " + B0s;
                valueB0.color = value ? "white" : "gray";
                sliderB0d.alpha = value ? 1 : 0.4;
                valueB0d.text = "dir = " + B0d.toFixed(0) + "°";
                valueB0d.color = value ? "white" : "gray";
            }

            const B0_magnitude_change = (value) => {
                B0s = Math.round(value, 2);
                B0_active(B0act); // Update based on B0s
            }
            const B0_direction_change = (value) => {
                B0d = value;
                B0_active(B0act);
            }

            checkbox1.width = "20px";
            checkbox1.height = "20px";
            checkbox1.color = "green";
            checkbox1.background = "gray";
            checkbox1.isChecked = B0act;
            checkbox1.onIsCheckedChangedObservable.add(B0_active);

            sliderB0.minimum = -100;
            sliderB0.maximum = 100;
            sliderB0.value = B0s;
            sliderB0.step = 1;
            sliderB0.height = "20px";
            sliderB0.width = "95%";
            sliderB0.color = "gray";
            sliderB0.background = "gray";
            sliderB0.thumbWidth = "4px";
            sliderB0.alpha = 0.4;
            sliderB0.onValueChangedObservable.add(B0_magnitude_change);

            valueB0d.text = `dir = 0`;
            valueB0d.color = "white";
            valueB0d.fontSize = 18;
            valueB0d.height = "25px";
            valueB0d.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;

            sliderB0d.minimum = 0;
            sliderB0d.maximum = 180;
            sliderB0d.value = B0d;
            sliderB0d.step = 0.1;
            sliderB0d.height = "20px";
            sliderB0d.width = "95%";
            sliderB0d.color = "gray";
            sliderB0d.background = "gray";
            sliderB0d.thumbWidth = "4px";
            sliderB0d.alpha = 0.4;
            sliderB0d.onValueChangedObservable.add(B0_direction_change);

            B0_magnitude_change(B0s); // Initialize based on B0s
            B0_direction_change(B0d); // Initialize based on B0d

            grid2.addControl(labelB0, 0, 0);
            grid2.addControl(checkbox1, 0, 1);
            grid2.addControl(sliderB0, 0, 2);
            grid2.addControl(valueB0, 0, 3);
            grid2.addControl(sliderB0d, 0, 4);
            grid2.addControl(valueB0d, 0, 5);


            // B1 controls ************************************************************


            const labelB1 = new BABYLON.GUI.TextBlock();
            const checkbox2 = new BABYLON.GUI.Checkbox();
            const valueB1 = new BABYLON.GUI.TextBlock();
            const sliderB1 = new BABYLON.GUI.Slider();
            const valueB1a = new BABYLON.GUI.TextBlock();
            const sliderB1a = new BABYLON.GUI.Slider();

            labelB1.text = `B1`;
            labelB1.color = "white";
            labelB1.fontSize = 18;
            labelB1.height = "25px";
            labelB1.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;

            const B1_active = (value) => {
                B1act = value;
                checkbox2.isChecked = value;
                sliderB1.alpha = value ? 1 : 0.4;
                valueB1.text = "R = " + B1s.toFixed(0);
                valueB1.color = value ? "white" : "gray";
                valueB1a.text = "ampl = " + B1a.toFixed(1);
                sliderB1a.alpha = value ? 1 : 0.4;
                valueB1a.color = value ? "white" : "gray";
            }

            const B1_amplitude_change = (value) => {
                B1a = value;
                B1_active(B1act);
            }
            const B1_frequency_change = (value) => {
                B1s = Math.round(value, 2);
                B1_active(B1act);
            }

            // B1a amplitude label
            valueB1a.fontSize = 18;
            valueB1a.height = "30px";
            valueB1a.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;

            // B1a amplitude slider
            sliderB1a.minimum = 0;
            sliderB1a.zIndex = 3;
            sliderB1a.maximum = 20;
            sliderB1a.value = B1a;
            sliderB1a.height = "20px";
            sliderB1a.width = "95%";
            sliderB1a.color = "gray";
            sliderB1a.step = 0.1;
            sliderB1a.thumbWidth = "4px";
            sliderB1a.background = "gray";
            sliderB1a.onValueChangedObservable.add(B1_amplitude_change);

            checkbox2.width = "20px";
            checkbox2.height = "20px";
            checkbox2.color = "green";
            checkbox2.background = "gray";
            checkbox2.isChecked = B1act;
            checkbox2.onIsCheckedChangedObservable.add(B1_active);

            valueB1.color = "white";
            valueB1.fontSize = 18;
            valueB1.height = "30px";
            valueB1.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;

            sliderB1.minimum = -100;
            sliderB1.maximum = 100;
            sliderB1.value = B1s;
            sliderB1.height = "20px";
            sliderB1.width = "95%";
            sliderB1.color = "gray";
            sliderB1.step = 1;
            sliderB1.thumbWidth = "4px";
            sliderB1.background = "gray";
            sliderB1.alpha = 0.4;
            sliderB1.onValueChangedObservable.add(B1_frequency_change);

            B1_amplitude_change(B1a); // Initialize based on B1a
            B1_frequency_change(B1s); // Initialize based on B1s

            grid2.addControl(labelB1, 1, 0);
            grid2.addControl(checkbox2, 1, 1);
            grid2.addControl(sliderB1, 1, 2);
            grid2.addControl(valueB1, 1, 3);
            grid2.addControl(sliderB1a, 1, 4);
            grid2.addControl(valueB1a, 1, 5);


            // Frame controls ************************************************************

            const labelF = new BABYLON.GUI.TextBlock();
            const valueF = new BABYLON.GUI.TextBlock();
            const sliderF = new BABYLON.GUI.Slider();
            const checkboxF = new BABYLON.GUI.Checkbox();

            const Fs_change = (value) => {
                Fs = value;
                valueF.text = `R = ` + Fs;
                sliderF.value = Fs;
            }

            checkboxF.width = "20px";
            checkboxF.height = "20px";
            checkboxF.color = "white";
            checkboxF.background = "gray";
            checkboxF.isChecked = showaxis;
            checkboxF.onIsCheckedChangedObservable.add(function (value) {
                showaxis = value;
            });
            //grid2.addControl(checkboxF, 2, 0);

            labelF.text = `Frame`;
            labelF.color = "white";
            labelF.fontSize = 18;
            labelF.height = "30px";
            labelF.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;

            valueF.color = "white";
            valueF.fontSize = 18;
            valueF.height = "30px";
            valueF.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;

            sliderF.minimum = -100;
            sliderF.maximum = 100;
            sliderF.value = 0;
            sliderF.height = "20px";
            sliderF.width = "95%";
            sliderF.color = "gray";
            sliderF.step = 1;
            sliderF.thumbWidth = "4px";
            sliderF.background = "gray";
            sliderF.onValueChangedObservable.add(function (value) {
                Fs_change(value);
            });

            Fs_change(Fs); // Initialize based on Fs

            grid2.addControl(labelF, 2, 0);
            grid2.addControl(checkboxF, 2, 1);
            grid2.addControl(sliderF, 2, 2);
            grid2.addControl(valueF, 2, 3);
            // Laser  controls ************************************************************

            const labelRel = new BABYLON.GUI.TextBlock();
            const valueRel = new BABYLON.GUI.TextBlock();
            const sliderRel = new BABYLON.GUI.Slider();

            labelRel.text = `Relax.`;
            labelRel.color = "white";
            labelRel.fontSize = 18;
            labelRel.height = "25px";
            labelRel.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;

            valueRel.text = `B0 R = 0`;
            valueRel.color = "white";
            valueRel.fontSize = 18;
            valueRel.height = "25px";
            valueRel.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;


            const Rel_change = (value) => {
                relax = value
                valueRel.text = "R = " + relax.toFixed(1);
            }

            sliderRel.minimum = 0;
            sliderRel.maximum = 10;
            sliderRel.value = relax;
            sliderRel.step = 0.1;
            sliderRel.height = "20px";
            sliderRel.width = "95%";
            sliderRel.color = "gray";
            sliderRel.background = "gray";
            sliderRel.thumbWidth = "4px";
            sliderRel.alpha = 0.4;
            sliderRel.onValueChangedObservable.add(Rel_change);

            Rel_change(relax);

            grid3.addControl(labelRel, 0, 0);
            grid3.addControl(sliderRel, 0, 1);
            grid3.addControl(valueRel, 0, 2);

            const labelPump = new BABYLON.GUI.TextBlock();
            const valuePump = new BABYLON.GUI.TextBlock();
            const sliderPump = new BABYLON.GUI.Slider();

            labelPump.text = `Pump`;
            labelPump.color = "white";
            labelPump.fontSize = 18;
            labelPump.height = "25px";
            labelPump.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;

            valuePump.text = `B0 R = 0`;
            valuePump.color = "white";
            valuePump.fontSize = 18;
            valuePump.height = "25px";
            valuePump.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;

            const Pump_change = (value) => {
                pump = value;
                valuePump.text = "R = " + pump.toFixed(1);
            }

            sliderPump.minimum = 0;
            sliderPump.maximum = 10;
            sliderPump.value = pump;
            sliderPump.step = 0.1;
            sliderPump.height = "20px";
            sliderPump.width = "95%";
            sliderPump.color = "gray";
            sliderPump.background = "gray";
            sliderPump.thumbWidth = "4px";
            sliderPump.alpha = 0.4;
            sliderPump.onValueChangedObservable.add(Pump_change);

            Pump_change(pump);

            grid3.addControl(labelPump, 1, 0);
            grid3.addControl(sliderPump, 1, 1);
            grid3.addControl(valuePump, 1, 2);

            const labelPumpDir = new BABYLON.GUI.TextBlock();
            const valuePumpDir = new BABYLON.GUI.TextBlock();
            const sliderPumpDir = new BABYLON.GUI.Slider();

            labelPumpDir.text = `Pu dir`;
            labelPumpDir.color = "white";
            labelPumpDir.fontSize = 18;
            labelPumpDir.height = "25px";
            labelPumpDir.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;

            valuePumpDir.text = `B0 R = 0`;
            valuePumpDir.color = "white";
            valuePumpDir.fontSize = 18;
            valuePumpDir.height = "25px";
            valuePumpDir.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;

            const PumpDir_change = (value) => {
                pumpdir = value;
                valuePumpDir.text = "dir = " + pumpdir.toFixed(0) + "°";
            }

            sliderPumpDir.minimum = 0;
            sliderPumpDir.maximum = 90;
            sliderPumpDir.value = pumpdir;
            sliderPumpDir.step = 1;
            sliderPumpDir.height = "20px";
            sliderPumpDir.width = "95%";
            sliderPumpDir.color = "gray";
            sliderPumpDir.background = "gray";
            sliderPumpDir.thumbWidth = "4px";
            sliderPumpDir.alpha = 0.4;
            sliderPumpDir.onValueChangedObservable.add(PumpDir_change);

            PumpDir_change(pumpdir);

            grid3.addControl(labelPumpDir, 2, 0);
            grid3.addControl(sliderPumpDir, 2, 1);
            grid3.addControl(valuePumpDir, 2, 2);


            // Larmor controls
            const checkboxL = new BABYLON.GUI.Checkbox();
            checkboxL.width = "20px";
            checkboxL.height = "20px";
            checkboxL.color = "white";
            checkboxL.background = "gray";
            checkboxL.isChecked = larmorth;
            checkboxL.onIsCheckedChangedObservable.add(function (value) {
                larmorth = value;
            });

            var panelL = new BABYLON.GUI.StackPanel();
            panelL.isVertical = false;
            panelL.HorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            grid2.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            const labelL = new BABYLON.GUI.TextBlock();
            labelL.text = `  Larmor theorem`;
            labelL.color = "white";
            labelL.fontSize = 18;
            labelL.height = "30px";
            labelL.width = "145px";
            labelL.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;

            panelL.addControl(labelL);
            panelL.addControl(checkboxL);

            grid2.addControl(panelL, 2, 4);


            /// options panel ************************************************************

            const checkboxH = new BABYLON.GUI.Checkbox();
            let showHistory = typeof window.initialValues.showhistory === "number" ? window.initialValues.showhistory : false;
            checkboxH.width = "20px";
            checkboxH.height = "20px";
            checkboxH.color = "white";
            checkboxH.background = "gray";            
            checkboxH.onIsCheckedChangedObservable.add(function (value) {
                showHistory = value;                
                if (value) {
                    resethist();
                }
            });
            checkboxH.isChecked = showHistory;            
            

            const labelH = new BABYLON.GUI.TextBlock();
            labelH.text = `  History`;
            labelH.color = "white";
            labelH.fontSize = 18;
            labelH.height = "30px";
            labelH.width = "80px";
            labelH.paddingLeft = "5px";
            labelH.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            labelH.onPointerDownObservable.add(function (value) {checkboxH.isChecked = !checkboxH.isChecked;});    


            const checkboxProj = new BABYLON.GUI.Checkbox();
            let showAxProj = typeof window.initialValues.axisprojections === "number" ? window.initialValues.axisprojections : false;
            checkboxProj.width = "20px";
            checkboxProj.height = "20px";
            checkboxProj.color = "white";
            checkboxProj.background = "gray";
            checkboxProj.isChecked = showAxProj;

            checkboxProj.onIsCheckedChangedObservable.add(function (value) {
                showAxProj = value;
            });

            const labelProj = new BABYLON.GUI.TextBlock();
            labelProj.text = `  Axis projections`;
            labelProj.color = "white";
            labelProj.fontSize = 18;
            labelProj.height = "30px";
            labelProj.width = "166px";
            labelProj.paddingLeft = "20px";
            labelProj.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            labelProj.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
            labelProj.onPointerDownObservable.add(function (value) {checkboxProj.isChecked = !checkboxProj.isChecked;});    

            const checkboxRFPhase = new BABYLON.GUI.Checkbox();
            let showRFPhase = typeof window.initialValues.showrfphase === "number" ? window.initialValues.showrfphase : false;
            checkboxRFPhase.width = "20px";
            checkboxRFPhase.height = "20px";
            checkboxRFPhase.color = "white";
            checkboxRFPhase.background = "gray";
            checkboxRFPhase.isChecked = showRFPhase;
            checkboxRFPhase.onIsCheckedChangedObservable.add(function (value) {
                showRFPhase = value;
            });

            const labelRFPhase = new BABYLON.GUI.TextBlock();
            labelRFPhase.text = `  RF phase`;
            labelRFPhase.color = "white";
            labelRFPhase.fontSize = 18;
            labelRFPhase.height = "30px";
            labelRFPhase.width = "117px";
            labelRFPhase.paddingLeft = "20px";
            labelRFPhase.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            labelRFPhase.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
            labelRFPhase.onPointerDownObservable.add(function (value) {checkboxRFPhase.isChecked = !checkboxRFPhase.isChecked;});    

            const checkboxRFPhaseProj = new BABYLON.GUI.Checkbox();
            let showRFPhaseProj = typeof window.initialValues.showphaseprojection === "number" ? window.initialValues.showphaseprojection : false;
            checkboxRFPhaseProj.width = "20px";
            checkboxRFPhaseProj.height = "20px";
            checkboxRFPhaseProj.color = "white";
            checkboxRFPhaseProj.background = "gray";
            checkboxRFPhaseProj.isChecked = showRFPhaseProj;
            checkboxRFPhaseProj.onIsCheckedChangedObservable.add(function (value) {
                showRFPhaseProj = value;
            });

            const labelRFPhaseProj = new BABYLON.GUI.TextBlock();
            labelRFPhaseProj.text = `  RF phase projection`;
            labelRFPhaseProj.color = "white";
            labelRFPhaseProj.fontSize = 18;
            labelRFPhaseProj.height = "30px";
            labelRFPhaseProj.width = "200px";
            labelRFPhaseProj.paddingLeft = "20px";
            labelRFPhaseProj.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            labelRFPhaseProj.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
            labelRFPhaseProj.onPointerDownObservable.add(function (value) {checkboxRFPhaseProj.isChecked = !checkboxRFPhaseProj.isChecked;});    

            const checkboxPlaneProj = new BABYLON.GUI.Checkbox();
            let showPlaneProj = typeof window.initialValues.showplaneprojection === "number" ? window.initialValues.showplaneprojection : false;
            checkboxPlaneProj.width = "20px";
            checkboxPlaneProj.height = "20px";
            checkboxPlaneProj.color = "white";
            checkboxPlaneProj.background = "gray";
            checkboxPlaneProj.isChecked = showPlaneProj;
            checkboxPlaneProj.onIsCheckedChangedObservable.add(function (value) {
                showPlaneProj = value;
            });

            const labelPlaneProj = new BABYLON.GUI.TextBlock();
            labelPlaneProj.text = `  Plane projection`;
            labelPlaneProj.color = "white";
            labelPlaneProj.fontSize = 18;
            labelPlaneProj.height = "30px";
            labelPlaneProj.width = "167px";
            labelPlaneProj.paddingLeft = "20px";
            labelPlaneProj.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            labelPlaneProj.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
            labelPlaneProj.onPointerDownObservable.add(function (value) {checkboxPlaneProj.isChecked = !checkboxPlaneProj.isChecked;});    


            const checkboxLinearRF = new BABYLON.GUI.Checkbox();
            let LinearRF = typeof window.initialValues.linearrf === "number" ? window.initialValues.linearrf : false;
            checkboxLinearRF.width = "20px";
            checkboxLinearRF.height = "20px";
            checkboxLinearRF.color = "white";
            checkboxLinearRF.background = "gray";
            checkboxLinearRF.isChecked = LinearRF;
            checkboxLinearRF.onIsCheckedChangedObservable.add(function (value) {
                LinearRF = value;
            });

            const labelLinearRF = new BABYLON.GUI.TextBlock();
            labelLinearRF.text = `  Linear RF`;
            labelLinearRF.color = "white";
            labelLinearRF.fontSize = 18;
            labelLinearRF.height = "30px";
            labelLinearRF.width = "118px";
            labelLinearRF.paddingLeft = "20px";
            labelLinearRF.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            labelLinearRF.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
            labelLinearRF.onPointerDownObservable.add(function (value) {checkboxLinearRF.isChecked = !checkboxLinearRF.isChecked;});    


            var panelH = new BABYLON.GUI.StackPanel();
            panelH.height = "35px";
            panelH.width = "100%";
            panelH.paddingLeft = "5px";
            panelH.paddingBottom = "15px";

            panelH.isVertical = false;
            panelH.addControl(labelH);
            panelH.addControl(checkboxH);
            panelH.addControl(labelProj);
            panelH.addControl(checkboxProj);

            panelH.addControl(labelPlaneProj);
            panelH.addControl(checkboxPlaneProj);

            panelH.addControl(labelRFPhase);
            panelH.addControl(checkboxRFPhase);
            panelH.addControl(labelRFPhaseProj);
            panelH.addControl(checkboxRFPhaseProj);

            panelH.addControl(labelLinearRF);
            panelH.addControl(checkboxLinearRF);




            Masaerpanel.addControl(panelH);


            /// buttons panel ************************************************************


            let paused = false;
            var buttonPause = BABYLON.GUI.Button.CreateSimpleButton("butPause", "Pause");
            buttonPause.verticalAlignment = 1;
            buttonPause.width = "110px";
            buttonPause.height = "28px";
            buttonPause.paddingLeft = "10px";
            buttonPause.paddingRight = "10px";
            buttonPause.color = "black";
            buttonPause.cornerRadius = 4;
            buttonPause.background = "#e0e0e0";
            buttonPause.onPointerUpObservable.add(function () {
                paused = !paused;
                buttonPause.textBlock.text = paused ? "Resume" : "Pause";
            });


            var button1 = BABYLON.GUI.Button.CreateSimpleButton("but1", "Reset Z");
            button1.verticalAlignment = 1;// (debugNode as BABYLON.Unknown)
            button1.width = "110px";
            button1.height = "28px";
            button1.paddingLeft = "10px";
            button1.paddingRight = "10px";
            button1.color = "black";
            button1.cornerRadius = 4;
            button1.background = "#e0e0e0";

            button1.onPointerUpObservable.add(function () {
                mag = new BABYLON.Vector3(0, 1., 0);
                resethist();
            });


            var button2 = BABYLON.GUI.Button.CreateSimpleButton("but2", "Reset X");
            button2.verticalAlignment = 1;
            button2.width = "110px";
            button2.height = "28px";
            button2.paddingLeft = "10px";
            button2.paddingRight = "10px";
            button2.color = "black";
            button2.cornerRadius = 4;
            button2.background = "#e0e0e0";
            button2.onPointerUpObservable.add(function () {
                mag = new BABYLON.Vector3(1., 0., 0.);
                resethist();
            });


            var buttonReset0 = BABYLON.GUI.Button.CreateSimpleButton("butMatchFrame", "Rest 0");
            buttonReset0.verticalAlignment = 1;
            buttonReset0.width = "110px";
            buttonReset0.height = "28px";
            buttonReset0.paddingLeft = "10px";
            buttonReset0.paddingRight = "10px";
            buttonReset0.color = "black";
            buttonReset0.cornerRadius = 4;
            buttonReset0.background = "#e0e0e0";
            buttonReset0.onPointerUpObservable.add(function () {

                mag = new BABYLON.Vector3(0., 0., 0.);
                resethist();
            });


            var buttonMatchFrame = BABYLON.GUI.Button.CreateSimpleButton("butMatchFrame", "rot. Frame");
            buttonMatchFrame.verticalAlignment = 1;
            buttonMatchFrame.width = "130px";
            buttonMatchFrame.height = "28px";
            buttonMatchFrame.paddingLeft = "10px";
            buttonMatchFrame.paddingRight = "10px";
            buttonMatchFrame.color = "black";
            buttonMatchFrame.cornerRadius = 4;
            buttonMatchFrame.background = "#e0e0e0";
            buttonMatchFrame.onPointerUpObservable.add(function () {
                // Set the frame frequency (Fs) to match the B0 frequency (B0s)
                if (Fs != 0) {
                    Fs_change(0);
                } else {
                    Fs_change(-B1s);
                }
            });

            var buttonB0rev = BABYLON.GUI.Button.CreateSimpleButton("butRerverse", "reverse B0");
            buttonB0rev.verticalAlignment = 1;
            buttonB0rev.width = "130px";
            buttonB0rev.height = "28px";
            buttonB0rev.paddingLeft = "10px";
            buttonB0rev.paddingRight = "10px";
            buttonB0rev.color = "black";
            buttonB0rev.cornerRadius = 4;
            buttonB0rev.background = "#e0e0e0";
            buttonB0rev.onPointerUpObservable.add(function () {
                if (larmorth) {
                    B0_magnitude_change(-(B0s + Fs) - Fs);
                } else {
                    B0_magnitude_change(-B0s);
                }

            });


            var buttonPiPulse = BABYLON.GUI.Button.CreateSimpleButton("butPiPulse", "pi Pulse");
            buttonPiPulse.verticalAlignment = 1;
            buttonPiPulse.width = "130px";
            buttonPiPulse.height = "28px";
            buttonPiPulse.paddingLeft = "10px";
            buttonPiPulse.paddingRight = "10px";
            buttonPiPulse.color = "black";
            buttonPiPulse.cornerRadius = 4;
            buttonPiPulse.background = "#e0e0e0";
            buttonPiPulse.onPointerUpObservable.add(function () {
                if (pulse == 0) {
                    pulse = Math.PI / 2.;
                    B1_active(true);
                }
            });


            
            var buttonLink = BABYLON.GUI.Button.CreateSimpleButton("butLink", "Generate link");
            buttonLink.verticalAlignment = 1;
            buttonLink.width = "170px";
            buttonLink.height = "28px";
            buttonLink.paddingLeft = "10px";
            buttonLink.paddingRight = "10px";
            buttonLink.color = "black";
            buttonLink.cornerRadius = 4;
            buttonLink.background = "#e0e0e0";
            buttonLink.onPointerUpObservable.add(function () {
                const link= window.location.href
                const slink = link.split("?");
                newlink=slink[0];              
                newlink += "?B0m=" + B0s;
                newlink += "&B0d=" + B0d; 
                newlink += "&B1f=" + B1s; 
                newlink += "&B1a=" + B1a; 
                newlink += "&Fs=" + Fs; 
                newlink += "&relax=" + relax;
                newlink += "&pump=" + pump; 
                newlink += "&pumpdir=" + pumpdir;                
                newlink += "&larmorth=" 
                newlink += larmorth? "1" : "0"; 
                newlink += "&showaxis=" 
                newlink += showaxis? "1" : "0";
                newlink += "&showhistory=" 
                newlink += showHistory? "1" : "0"; 
                newlink += "&axisprojections="
                newlink += showAxProj? "1" : "0"; 
                newlink += "&showrfphase=" 
                newlink += showRFPhase? "1" : "0";
                newlink += "&showphaseprojection=" 
                newlink += showRFPhaseProj? "1" : "0";
                newlink += "&showplaneprojection=" 
                newlink +=showPlaneProj? "1" :"0"; 
                newlink += "&linearrf=" 
                newlink += LinearRF? "1" : "0";                 
                console.log("Link to this simulation: " + newlink);
                window.open(newlink, '_blank').focus();
            });

            var panelB = new BABYLON.GUI.StackPanel();
            panelB.height = "28px";
            panelB.width = "100%";
            panelB.paddingLeft = "10px";
            panelB.isVertical = false;
            panelB.addControl(buttonPause);
            panelB.addControl(button1);
            panelB.addControl(button2);
            panelB.addControl(buttonReset0);
            panelB.addControl(buttonMatchFrame);
            panelB.addControl(buttonB0rev);
            panelB.addControl(buttonPiPulse);
            panelB.addControl(buttonLink);
            Masaerpanel.addControl(panelB);



            var line = new BABYLON.GUI.MultiLine();
            line.add(sliderB0);
            line.add(sliderF);
            line.lineWidth = 1;
            line.color = "gray";
            line.zIndex = 1;
            gui.addControl(line);

            B0 = new BABYLON.Vector3(0., 1, 0);
            B1 = new BABYLON.Vector3(0., 0, 0);

            let ax_x = BABYLON.MeshBuilder.CreateTube("y axis", { path: AxisCurve(new BABYLON.Vector3(1.5, 0, 0)), radiusFunction: smallradiusChange, sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: true }, scene);
            let ax_z = BABYLON.MeshBuilder.CreateTube("z axis", { path: AxisCurve(new BABYLON.Vector3(0, 0, 1.5)), radiusFunction: smallradiusChange, sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: true }, scene);
            let axisMat = new BABYLON.StandardMaterial("axisMat", scene);
            axisMat.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.8); // light gray

            ax_x.material = axisMat;
            ax_z.material = axisMat;

            let rf_a = BABYLON.MeshBuilder.CreateTube("rf phase", { path: ArrowCurve(rfvec), radiusFunction: smallradiusChange, sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: true }, scene);


            let mag_a = BABYLON.MeshBuilder.CreateTube("magnetization", { path: ArrowCurve(mag), radiusFunction: MagradiusChange, sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: true }, scene);
            let magpx_a = BABYLON.MeshBuilder.CreateTube("magnetization x", { path: ArrowCurve(new BABYLON.Vector3(mag.x, 0, 0)), radiusFunction: MagPradiusChange, sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: true }, scene);
            let magpy_a = BABYLON.MeshBuilder.CreateTube("magnetization y", { path: ArrowCurve(new BABYLON.Vector3(0, mag.y, 0)), radiusFunction: MagPradiusChange, sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: true }, scene);
            let magpz_a = BABYLON.MeshBuilder.CreateTube("magnetization z", { path: ArrowCurve(new BABYLON.Vector3(0, 0, mag.z)), radiusFunction: MagPradiusChange, sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: true }, scene);

            let mag_mat = new BABYLON.StandardMaterial("Magmat", scene);
            mag_mat.diffuseColor = new BABYLON.Color3(1, 1, 0); // green
            mag_a.material = mag_mat;
            magpx_a.material = mag_mat;
            magpy_a.material = mag_mat;
            magpz_a.material = mag_mat;

            let pumplaser = BABYLON.MeshBuilder.CreateTube("pumplaser", { path: LaserArrowCurve(pumpdir), radiusFunction: BradiusChange, sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: true }, scene);
            let laser_mat = new BABYLON.StandardMaterial("axisMat", scene);

            laser_mat.diffuseColor = new BABYLON.Color3(1, 0, 0); //  red                        
            //laser_mat.emissiveColor = new BABYLON.Color3(0.5, 0, 0); 
            pumplaser.material = laser_mat;


            let B0_a = BABYLON.MeshBuilder.CreateTube("B0", { path: ArrowCurve(B0), radiusFunction: BradiusChange, sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: true }, scene);
            let B1_a = BABYLON.MeshBuilder.CreateTube("B1", { path: ArrowCurve(B1), radiusFunction: BradiusChange, sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: true }, scene);
            let B_mat = new BABYLON.StandardMaterial("B0Mat", scene);
            B_mat.diffuseColor = new BABYLON.Color3(0, 0.8, 0); // green
            B0_a.material = B_mat;
            B1_a.material = B_mat;


            let hist = BABYLON.MeshBuilder.CreateLines("lines", { points: histPoints, updatable: true, colors: histcolors, useVertexAlpha: true }, scene);
//            hist.use

            let angle = 0.000;

            let dt = 0.02
            let len = 1000;

            let rfphase = 0.0;
            let framephase = 0.0;

            scene.registerBeforeRender(function () {


                // B0d is in degrees, convert to radians
                const B0dRad = B0d * Math.PI / 180;
                // B0s/20 is the magnitude
                const B0mag = B0s / 20.;
                // Rotate B0 around z-axis by B0d
                B0 = new BABYLON.Vector3(
                    B0act * B0mag * Math.sin(B0dRad),
                    B0act * B0mag * Math.cos(B0dRad),
                    0
                );


                const dirrad = pumpdir * Math.PI / 180;

                pumpmag = new BABYLON.Vector3(
                    2. * Math.sin(dirrad),
                    2. * Math.cos(dirrad),
                    0
                );

                let B = new BABYLON.Vector3;

                B0L = new BABYLON.Vector3(B0.x, B0.y + larmorth * Fs / 20., B0.z);
                B1 = new BABYLON.Vector3(B1act * B1a / 20. * Math.sin(rfphase), 0, B1act * B1a / 20. * Math.cos(rfphase));

                if (!paused) {

                    for (let i = 0; i < len; i++) {
                        rfphase += B1s * dt / len / 20.;
                        framephase += Fs * dt / len / 20.;

                        if (pulse > 0) {
                            pulse -= B1a / 20. * dt / len;
                            if (pulse <= 0) {
                                pulse = 0;
                                B1_active(false);
                            }
                        }

                        if (LinearRF) {
                            B1 = new BABYLON.Vector3(2 * B1act * B1a / 20. * Math.sin(rfphase), 0, 0);
                        } else {
                            B1 = new BABYLON.Vector3(B1act * B1a / 20. * Math.sin(rfphase), 0, B1act * B1a / 20. * Math.cos(rfphase));
                        }

                        B.x = B0.x + B1.x;
                        B.y = B0.y + B1.y;
                        B.z = B0.z + B1.z;

                        mag.x += dt / len * (-mag.y * B.z + mag.z * B.y - relax / 20. * mag.x + pump / 20. * (pumpmag.x - mag.x));
                        mag.y += dt / len * (-mag.z * B.x + mag.x * B.z - relax / 20. * mag.y + pump / 20. * (pumpmag.y - mag.y));
                        mag.z += dt / len * (-mag.x * B.y + mag.y * B.x - relax / 20. * mag.z + pump / 20. * (pumpmag.z - mag.z));
                    }
                }


                //                console.log(" B1: " + B1.toString() +", b1act:"+ B1act);
                // console.log("pulse "+pulse);
                mag_a = BABYLON.MeshBuilder.CreateTube("magnetization", { path: ArrowCurve(mag), radiusFunction: MagradiusChange, sideOrientation: BABYLON.Mesh.DOUBLESIDE, instance: mag_a, updatable: true });

                if (showAxProj) {
                    magpx_a.visibility = true;
                    magpy_a.visibility = true;
                    magpz_a.visibility = true;
                    magpx_a = BABYLON.MeshBuilder.CreateTube("magnetization x", { path: ArrowCurve(new BABYLON.Vector3(mag.x, 0, 0)), radiusFunction: MagPradiusChange, sideOrientation: BABYLON.Mesh.DOUBLESIDE, instance: magpx_a, updatable: true });
                    magpy_a = BABYLON.MeshBuilder.CreateTube("magnetization y", { path: ArrowCurve(new BABYLON.Vector3(0, mag.y, 0)), radiusFunction: MagPradiusChange, sideOrientation: BABYLON.Mesh.DOUBLESIDE, instance: magpy_a, updatable: true });
                    magpz_a = BABYLON.MeshBuilder.CreateTube("magnetization z", { path: ArrowCurve(new BABYLON.Vector3(0, 0, mag.z)), radiusFunction: MagPradiusChange, sideOrientation: BABYLON.Mesh.DOUBLESIDE, instance: magpz_a, updatable: true });
                    magpx_a.rotation.y = framephase;
                    magpy_a.rotation.y = framephase;
                    magpz_a.rotation.y = framephase;
                } else if (showPlaneProj) {
                    magpx_a.visibility = true;
                    magpy_a.visibility = true;
                    magpz_a.visibility = false;
                    magpx_a = BABYLON.MeshBuilder.CreateTube("magnetization x", { path: ArrowCurve(new BABYLON.Vector3(mag.x, 0, mag.z)), radiusFunction: MagPradiusChange, sideOrientation: BABYLON.Mesh.DOUBLESIDE, instance: magpx_a, updatable: true });
                    magpy_a = BABYLON.MeshBuilder.CreateTube("magnetization z", { path: ArrowCurve(new BABYLON.Vector3(0, mag.y, 0)), radiusFunction: MagPradiusChange, sideOrientation: BABYLON.Mesh.DOUBLESIDE, instance: magpy_a, updatable: true });
                    magpx_a.rotation.y = framephase;
                    magpy_a.rotation.y = framephase;

                } else if (showRFPhaseProj) {
                    magpx_a.visibility = true;
                    magpy_a.visibility = true;
                    magpz_a.visibility = true;

                    let projIP = (mag.x * Math.sin(rfphase) + mag.z * Math.cos(rfphase));
                    let projQU = (mag.x * Math.cos(rfphase) + mag.z * -1. * Math.sin(rfphase));

                    rfvec.x = (projIP * Math.sin(rfphase));
                    rfvec.z = (projIP * Math.cos(rfphase));

                    magpx_a = BABYLON.MeshBuilder.CreateTube("magnetization x", { path: ArrowCurve(new BABYLON.Vector3(rfvec.x, 0, rfvec.z)), radiusFunction: MagPradiusChange, sideOrientation: BABYLON.Mesh.DOUBLESIDE, instance: magpx_a, updatable: true });

                    magpy_a = BABYLON.MeshBuilder.CreateTube("magnetization y", { path: ArrowCurve(new BABYLON.Vector3(0, mag.y, 0)), radiusFunction: MagPradiusChange, sideOrientation: BABYLON.Mesh.DOUBLESIDE, instance: magpy_a, updatable: true });

                    rfvec.x = (projQU * Math.cos(rfphase));
                    rfvec.z = (projQU * -1. * Math.sin(rfphase));
                    magpz_a = BABYLON.MeshBuilder.CreateTube("magnetization z", { path: ArrowCurve(new BABYLON.Vector3(rfvec.x, 0, rfvec.z)), radiusFunction: MagPradiusChange, sideOrientation: BABYLON.Mesh.DOUBLESIDE, instance: magpz_a, updatable: true });

                    magpx_a.rotation.y = framephase;
                    magpy_a.rotation.y = framephase;
                    magpz_a.rotation.y = framephase;

                } else {
                    magpx_a.visibility = false;
                    magpy_a.visibility = false;
                    magpz_a.visibility = false;
                }


                B0_a = BABYLON.MeshBuilder.CreateTube("B0", { path: ArrowCurve(B0L), radiusFunction: BradiusChange, sideOrientation: BABYLON.Mesh.DOUBLESIDE, instance: B0_a, updatable: true });
                B1_a = BABYLON.MeshBuilder.CreateTube("B1", { path: ArrowCurve(B1), radiusFunction: BradiusChange, sideOrientation: BABYLON.Mesh.DOUBLESIDE, instance: B1_a, updatable: true });

                if (showRFPhaseProj) {
                } else {

                }

                hist.visibility = showHistory ? 1 : 0;

                if (showRFPhase) {
                    rfvec.x = 0.3 * Math.sin(rfphase);
                    rfvec.z = 0.3 * Math.cos(rfphase);
                    rf_a.visibility = true;
                    rf_a = BABYLON.MeshBuilder.CreateTube("rf phase", { path: ArrowCurve(rfvec), radiusFunction: smallradiusChange, sideOrientation: BABYLON.Mesh.DOUBLESIDE, instance: rf_a, updatable: true });
                    rf_a.rotation.y = framephase;
                } else {
                    rf_a.visibility = false;
                }


                // Update history
                histPoints.push(mag.clone());
                if (histPoints.length > 1000) {
                    histPoints.shift(); // Remove the oldest point
                }

                if (pump > 0) {
                    pumplaser.visibility = true;
                    pumplaser = BABYLON.MeshBuilder.CreateTube("pumplaser", { path: LaserArrowCurve(pumpdir), radiusFunction: BradiusChange, sideOrientation: BABYLON.Mesh.DOUBLESIDE, instance: pumplaser, updatable: true });
                    pumplaser.rotation.y = framephase;
                } else {
                    pumplaser.visibility = false;
                }

                hist = BABYLON.MeshBuilder.CreateLines("lines", { points: histPoints, instance: hist });
                hist.rotation.y = framephase;

                mag_a.rotation.y = framephase;
                B0_a.rotation.y = framephase;
                B1_a.rotation.y = framephase;

                ax_x.rotation.y = framephase;
                ax_z.rotation.y = framephase;


                if (showaxis) {
                    ax_x.visibility = 1;
                    ax_z.visibility = 1;
                } else {
                    ax_x.visibility = 0;
                    ax_z.visibility = 0;
                }


            })

            // Finally create the motion blur effect :)
            //var mb = new BABYLON.MotionBlurPostProcess('mb', scene, 1, camera);


            return scene;
        };

        window.initFunction = async function () {



            var asyncEngineCreation = async function () {
                try {
                    return createDefaultEngine();
                } catch (e) {
                    console.log("the available createEngine function failed. Creating the default engine instead");
                    return createDefaultEngine();
                }
            }

            window.engine = await asyncEngineCreation();

            const engineOptions = window.engine.getCreationOptions?.();
            if (!engineOptions || engineOptions.audioEngine !== false) {

            }
            if (!engine) throw 'engine should not be null.';
            startRenderLoop(engine, canvas);
            window.scene = createScene();
        };
        initFunction().then(() => {
            sceneToRender = scene
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>

</html>